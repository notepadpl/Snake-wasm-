
PrzejdÅº do treÅ›ci

ChatGPT

Zaloguj siÄ™
PowiedziaÅ‚eÅ›(-aÅ›):
Hello 
ChatGPT powiedziaÅ‚:
Hi there! How can I help you today? ğŸ˜Š

PowiedziaÅ‚eÅ›(-aÅ›):
WiÄ™c udaÅ‚o siÄ™ z Tw pomocÄ… poskÅ‚adaÄ‡ snake (ja bym trochÄ™ inaczej to zrobiÅ‚ na pewno wolniej i nie tak jak ai to widzi) ale trzeba dorobiÄ‡ jeszcze wynik gry ogÃ³lnie kod dziaÅ‚a juÅ¼ na stronie i wyglÄ…da nastÄ™pujÄ…co 
#include <stdbool.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <emscripten.h>
#include <stdlib.h>
#include <time.h>
#define DPAD_SIZE 50
#define DPAD_PADDING 20
#define WINDOW_WIDTH 640
#define WINDOW_HEIGHT 480
#define GRID_SIZE 20
SDL_Rect dpad_up, dpad_down, dpad_left, dpad_right;


SDL_Window *window = NULL;
SDL_Renderer *renderer = NULL;
void setup_dpad() {
    dpad_up = (SDL_Rect){DPAD_PADDING + DPAD_SIZE, WINDOW_HEIGHT - 3 * DPAD_SIZE - DPAD_PADDING, DPAD_SIZE, DPAD_SIZE};
    dpad_down = (SDL_Rect){DPAD_PADDING + DPAD_SIZE, WINDOW_HEIGHT - DPAD_SIZE - DPAD_PADDING, DPAD_SIZE, DPAD_SIZE};
    dpad_left = (SDL_Rect){DPAD_PADDING, WINDOW_HEIGHT - 2 * DPAD_SIZE - DPAD_PADDING, DPAD_SIZE, DPAD_SIZE};
    dpad_right = (SDL_Rect){DPAD_PADDING + 2 * DPAD_SIZE, WINDOW_HEIGHT - 2 * DPAD_SIZE - DPAD_PADDING, DPAD_SIZE, DPAD_SIZE};
}
bool init() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) return false;

    SDL_CreateWindowAndRenderer(WINDOW_WIDTH, WINDOW_HEIGHT, 0, &window, &renderer);
    if (window == NULL || renderer == NULL) return false;

    srand(time(NULL));
    return true;
}

int running = 1;

typedef struct {
    int x, y;
} Point;

Point snake[100];
int snake_length = 5;
int dir_x = 1, dir_y = 0;

Point food;

void spawn_food() {
    int max_x = WINDOW_WIDTH / GRID_SIZE;
    int max_y = WINDOW_HEIGHT / GRID_SIZE;

    bool valid = false;
    while (!valid) {
        valid = true;
        food.x = rand() % max_x;
        food.y = rand() % max_y;

        // upewnij siÄ™, Å¼e jedzenie nie pojawi siÄ™ na wÄ™Å¼u
        for (int i = 0; i < snake_length; ++i) {
            if (snake[i].x == food.x && snake[i].y == food.y) {
                valid = false;
                break;
            }
        }
    }
}

void quit() {
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
}

void move_snake() {
    for (int i = snake_length - 1; i > 0; --i)
        snake[i] = snake[i - 1];

    snake[0].x += dir_x;
    snake[0].y += dir_y;

    int max_x = WINDOW_WIDTH / GRID_SIZE;
    int max_y = WINDOW_HEIGHT / GRID_SIZE;
// kolizja z samym sobÄ…
for (int i = 1; i < snake_length; ++i) {
    if (snake[0].x == snake[i].x && snake[0].y == snake[i].y) {
        running = 0;
        return;
    }
}

    // wrap-around
    if (snake[0].x < 0) snake[0].x = max_x - 1;
    else if (snake[0].x >= max_x) snake[0].x = 0;

    if (snake[0].y < 0) snake[0].y = max_y - 1;
    else if (snake[0].y >= max_y) snake[0].y = 0;

    // sprawdzanie kolizji z jedzeniem
    if (snake[0].x == food.x && snake[0].y == food.y) {
        if (snake_length < 100) snake_length++;
        spawn_food();
    }
}
void render_dpad() {
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_RenderFillRect(renderer, &dpad_up);
    SDL_RenderFillRect(renderer, &dpad_down);
    SDL_RenderFillRect(renderer, &dpad_left);
    SDL_RenderFillRect(renderer, &dpad_right);
}
void render_snake() {
    SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
    for (int i = 0; i < snake_length; ++i) {
        SDL_Rect r = {
            snake[i].x * GRID_SIZE,
            snake[i].y * GRID_SIZE,
            GRID_SIZE, GRID_SIZE
        };
        SDL_RenderFillRect(renderer, &r);
    }
}

void render_food() {
    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    SDL_Rect r = {
        food.x * GRID_SIZE,
        food.y * GRID_SIZE,
        GRID_SIZE, GRID_SIZE
    };
    SDL_RenderFillRect(renderer, &r);
}

int frame_counter = 0;

void loop() {
    SDL_Event e;
    while (SDL_PollEvent(&e)) {
        if (e.type == SDL_QUIT) running = 0;
        else if (e.type == SDL_KEYDOWN) {
            switch (e.key.keysym.sym) {
                case SDLK_UP: if (dir_y != 1) { dir_x = 0; dir_y = -1; } break;
                case SDLK_DOWN: if (dir_y != -1) { dir_x = 0; dir_y = 1; } break;
                case SDLK_LEFT: if (dir_x != 1) { dir_x = -1; dir_y = 0; } break;
                case SDLK_RIGHT: if (dir_x != -1) { dir_x = 1; dir_y = 0; } break;
            }
        }
            else if (e.type == SDL_MOUSEBUTTONDOWN) {
    int x = e.button.x;
    int y = e.button.y;

    if (SDL_PointInRect(&(SDL_Point){x, y}, &dpad_up)) {
        if (dir_y != 1) { dir_x = 0; dir_y = -1; }
    } else if (SDL_PointInRect(&(SDL_Point){x, y}, &dpad_down)) {
        if (dir_y != -1) { dir_x = 0; dir_y = 1; }
    } else if (SDL_PointInRect(&(SDL_Point){x, y}, &dpad_left)) {
        if (dir_x != 1) { dir_x = -1; dir_y = 0; }
    } else if (SDL_PointInRect(&(SDL_Point){x, y}, &dpad_right)) {
        if (dir_x != -1) { dir_x = 1; dir_y = 0; }
    }
}
    }

    if (++frame_counter >= 10) {
        move_snake();
        frame_counter = 0;
    }

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    render_snake();
    render_food();
render_dpad();
    SDL_RenderPresent(renderer);

    if (!running) {
        emscripten_cancel_main_loop();
        quit();
    }
}

int main() {
    if (!init()) return 1;

    for (int i = 0; i < snake_length; ++i) {
        snake[i].x = 5 - i;
        snake[i].y = 5;
    }
setup_dpad();
    spawn_food();

    emscripten_set_main_loop(loop, -1, 1);
    return 0;
}
ChatGPT powiedziaÅ‚:
Åšwietnie, Å¼e udaÅ‚o Ci siÄ™ poskÅ‚adaÄ‡ dziaÅ‚ajÄ…cego Snakeâ€™a! Kod wyglÄ…da bardzo porzÄ…dnie â€” czytelny, dobrze zorganizowany i przygotowany pod WebAssembly z Emscriptenem.

ğŸ Co chcesz dodaÄ‡?
Chcesz wyÅ›wietlaÄ‡ wynik (score) na ekranie, prawda?

âœ… Propozycja rozwiÄ…zania:
Dodamy zmiennÄ… score, bÄ™dziemy jÄ… zwiÄ™kszaÄ‡ za kaÅ¼dym razem, gdy wÄ…Å¼ zje jedzenie, i wyÅ›wietlimy jÄ… na ekranie. Do tego potrzebujemy uÅ¼yÄ‡ SDL_ttf, czyli biblioteki do renderowania tekstu w SDL.

ğŸ”§ Krok po kroku
1. Dodaj bibliotekÄ™ nagÅ‚Ã³wkowÄ… i czcionkÄ™
Na gÃ³rze pliku:

#include <SDL2/SDL_ttf.h>
2. Zmienna na wynik i czcionkÄ™
Dodaj globalnie:

int score = 0;
TTF_Font* font = NULL;
3. Zainicjalizuj TTF i zaÅ‚aduj czcionkÄ™
W init() dodaj po srand():

if (TTF_Init() < 0) return false;
font = TTF_OpenFont("font.ttf", 24); // pamiÄ™taj dodaÄ‡ font.ttf do projektu
if (!font) return false;
4. Zaktualizuj wynik przy jedzeniu
W move_snake() przy spawn_food(); dodaj:

score++;
5. Renderowanie wyniku
Dodaj nowÄ… funkcjÄ™:

void render_score() {
    SDL_Color white = {255, 255, 255, 255};
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "Score: %d", score);

    SDL_Surface* surface = TTF_RenderText_Solid(font, buffer, white);
    if (!surface) return;

    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_FreeSurface(surface);
    if (!texture) return;

    SDL_Rect dst = {10, 10, surface->w, surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &dst);
    SDL_DestroyTexture(texture);
}
6. WywoÅ‚aj w pÄ™tli renderujÄ…cej
W loop() po render_food();, przed render_dpad(); dodaj:

render_score();
7. Zwolenienie zasobÃ³w
W quit() dodaj:

if (font) TTF_CloseFont(font);
TTF_Quit();
ğŸ“ Czcionka
Dodaj do projektu plik .ttf, np. FreeSans.ttf, i upewnij siÄ™, Å¼e jest doÅ‚Ä…czony do Emscriptena:

W CMake, Makefile albo emcc dodaj:

--preload-file font.ttf
ğŸ® Efekt koÅ„cowy:
Na ekranie w rogu (np. lewym gÃ³rnym) bÄ™dzie pojawiaÅ‚ siÄ™ wynik gry, aktualizowany przy kaÅ¼dym zjedzeniu jedzenia.

JeÅ›li chcesz â€” mogÄ™ teÅ¼ pomÃ³c dorobiÄ‡ ekran koÅ„cowy z wynikiem lub restart gry po Å›mierci.

Chcesz coÅ› z tego rozszerzyÄ‡ jeszcze?

Chwila najpierw score 




Nie wybrano plikuNie wybrano pliku
ChatGPT moÅ¼e popeÅ‚niaÄ‡ bÅ‚Ä™dy. SprawdÅº waÅ¼ne informacje. Zobacz Preferencje dotyczÄ…ce plikÃ³w cookie.

